I"›<h3 id="taking-the-leap-not-the-plunge">Taking the leap, not the <em>plunge</em></h3>
<p>Personally, Iâ€™ve always wanted to contribute to an open-source project, but never found a way to incorporate it with my day-to-day work. Occasionally, Iâ€™d muster up the courage to clone a project I liked, seeking a good entry point to add some new feature or handle some issue. I thought that all I needed was to make a small contribution and everything else would just flow into place.</p>

<p>Turns out, this may be true for <em>small-scale</em> projects, but for complex ones like OpenSearch this isnâ€™t the case. While you may fix a minor bug, youâ€™re not likely to know where to begin in order to fix a moderate bug or design a new feature. Searching for that entry point via the <code class="language-plaintext highlighter-rouge">main()</code> entrance mostly feels like wandering around an <a href="https://en.wikipedia.org/wiki/Relativity_(M._C._Escher)">M.C. Escher</a> print.</p>

<p>However, some projects have an entrance unlike any other - a <strong>Pluggable Architecture</strong>.</p>

<p>A pluggable architecture enables us to have a hands on experience with a logical sub section of a large-scale project. This effect makes such an immense project more approachable despite its overall size.</p>

<p>In this blog post, I will take you on a journey through my thought process and conclusions from building <em>my</em> first OpenSearch plugin. We will build a simple REST plugin together, install it into OpenSearch, and run it. By the end, I hope to convince you that it is a great starting point for you gaining hands-on experience required for joining the OpenSearch community of contributors, and a great starting point for the project itself.</p>

<hr />
<ul>
  <li><a href="#">My First Steps in OpenSearch Plugins</a>
    <ul>
      <li><a href="#taking-the-leap-not-the-plunge">Taking the leap, not the <em>plunge</em></a></li>
      <li><a href="#what-are-opensearch-plugins">What are OpenSearch Plugins?</a></li>
    </ul>
  </li>
  <li><a href="#building-a-simple-opensearch-rest-plugin">Building a Simple OpenSearch REST Plugin</a>
    <ul>
      <li><a href="#before-we-start---make-sure-you-have-these-environment-dependencies">Before we start - make sure you have these environment dependencies</a></li>
      <li><a href="#defining-our-plugin-requirements-for-opensearch">Defining Our Plugin Requirements for OpenSearch</a></li>
      <li><a href="#the-buildgradle-of-our-plugin">The <code class="language-plaintext highlighter-rouge">build.gradle</code> of Our Plugin</a></li>
      <li><a href="#implementing-the-plugin-code">Implementing the Plugin Code</a></li>
      <li><a href="#opensearch-plugin-interfaces">OpenSearch Plugin Interfaces</a></li>
      <li><a href="#implementing-plugin-logic">Implementing Plugin logic</a></li>
      <li><a href="#logic-separation">Logic separation</a></li>
      <li><a href="#testing">Testing</a></li>
    </ul>
  </li>
  <li><a href="#trying-out-our-new-plugin">Trying out our new plugin</a>
    <ul>
      <li><a href="#building-the-plugin-project">Building the plugin project</a></li>
      <li><a href="#installing-the-plugin">Installing the plugin</a></li>
      <li><a href="#running-opensearch-with-our-new-plugin">Running OpenSearch with our new plugin</a></li>
      <li><a href="#uninstalling-the-plugin">Uninstalling the plugin</a></li>
    </ul>
  </li>
  <li><a href="#key-takeaways-from-creating-my-first-plugin">Key takeaways from creating my first plugin</a></li>
</ul>

<h2 id="what-are-opensearch-plugins">What are OpenSearch Plugins?</h2>

<p>Software plugins are, in essence, standalone components that <strong>add features and capabilities</strong> to an existing core program.</p>

<p><img src="//assets/media/blog-images/2021-06-03-my-first-steps-in-opensearch-plugins/plugins-architectural-diagram.jpg" alt="Figure 1: Plugins architectural diagram" class="img-fluid" /></p>

<p>Normally, when viewing a pluginâ€™s code you wouldnâ€™t see <em>any</em> point of entry (no <code class="language-plaintext highlighter-rouge">main()</code>). Thatâ€™s because the pluginâ€™s points of entry are the interface functions that it implements.</p>

<p>OpenSearch plugins are no different.</p>

<p>As an analogy, think of how you can replace lenses and flash elements on a camera body. The core project is the part that <em>takes the picture</em>. It contains things a camera must have such as a light sensor and the software required to record the sensorâ€™s information. Plugins then would be what you can <em>connect to the camera body</em>.</p>

<p>Take for example, a wide angle lens to take pictures of landscapes. Maybe a cool feature would be to keep the camera still without touching it? Or taking it under water? You could install a tripod or a protective waterproof case respectively. Consider also that these plugins connect to the camera body in some way. To create one yourself you must first know 1) how to connect to the camera, and 2) how to interact with it via these connections â€“ this is called the <strong>plugin interface</strong>.</p>

<p>If you are designing a way for the camera to store more images on a new form of memory chip, then you donâ€™t need to know anything about the interface of the lenses. However, you would have to know a great deal about how this camera sends/retrieves its recorded file via the memory chip connectors.</p>

<p>In other words, the plugin interface is not necessarily the same for every plugin.</p>

<p>The beauty of this architecture is that it enables you to customize the core program to your needs, without having to contribute to the core project directly (Imagine having to buy a new camera for every different lens instead of switching the lenses!).</p>

<p>Letâ€™s get back to OpenSearch plugins:</p>

<p>Some plugins, for historic reasons, reside in the core project. 
An example of one of these is the <a href="https://github.com/opensearch-project/OpenSearch/tree/main/plugins/repository-s3/src"><code class="language-plaintext highlighter-rouge">repository-s3 plugin</code></a> that implements snapshot and restore capabilities using AWSâ€™s S3 buckets as the repository.</p>

<p>They are <em>in the open-source project repository</em>. However, when we create the binaries of the OpenSearch project (<code class="language-plaintext highlighter-rouge">~ gradle build</code>) these plugins are <strong>not installed</strong>. This is by design â€“ ensuring the release artifact is not huge by default.</p>

<p>Ideally, the OpenSearch project would be <em>pluggable</em> but contain no plugins in the project itself.</p>

<p>As mentioned previously, an important characteristic of a pluggable architecture is the plugin interface. This interface needs 1) to be as stable as possible and 2) to strive to be backwards-compatible throughout the different project versions. Otherwise, existing plugins will be very hard to maintain. This is similar to maintaining a public API.</p>

<p>This brings us to the plugins built by the community and completely independent of the main project.
The ability to add plugins offers some key benefits to the open source community:</p>
<ol>
  <li>Adding new features to OpenSearch can be done independently of the core project â€“ it allows for a wide range of features to be developed with few (if any) conflicts in the code.</li>
  <li>Writing a plugin for OpenSearch requires going through the core projectâ€™s source code. By creating plugins, <strong>you are gaining the skills to be part of the OpenSearch community</strong>.</li>
</ol>

<p>OpenSearch plugins vary greatly in complexity and functionality, yet they all have common characteristics. Letâ€™s get to know them by creating a simple REST plugin â€“ a plugin that implements a new REST endpoint in the OpenSearch project, reachable via an HTTP call to the running cluster.</p>

<h1 id="building-a-simple-opensearch-rest-plugin">Building a Simple OpenSearch REST Plugin</h1>

<h3 id="before-we-start---make-sure-you-have-these-environment-dependencies">Before we start - make sure you have these environment dependencies</h3>
<blockquote>
  <ul>
    <li>Java 14</li>
    <li>Gradle 7.0+<br />
(donâ€™t forget to add them to <code class="language-plaintext highlighter-rouge">$JAVA_HOME</code> and <code class="language-plaintext highlighter-rouge">$PATH</code>)</li>
  </ul>
</blockquote>

<h3 id="defining-our-plugin-requirements-for-opensearch">Defining Our Plugin Requirements for OpenSearch</h3>
<p>Letâ€™s say we would like to add a new endpoint to OpenSearch called <code class="language-plaintext highlighter-rouge">_plugins/hello_world</code> with the following behavior:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  ~ curl -XGET 'localhost:9200/_plugins/hello_world'

        Hi! Your plugin is installed and working:)

âžœ  ~ curl -XPOST 'localhost:9200/_plugins/hello_world' -H 'Content-Type: application/json' -d '{"name":"Amitai"}'

        Hi Amitai! Your plugin is installed and working:)
</code></pre></div></div>
<p>That is all we should start with. Anything more ambitious would keep us from focusing on the basics of plugins.</p>

<p>I am going to be writing the plugin using the <a href="https://github.com/opensearch-project/opensearch-plugins/blob/main/CONVENTIONS.md">plugin writing conventions</a> suggested in the OpenSearch projectâ€™s <code class="language-plaintext highlighter-rouge">opensearch-plugins</code> repo.</p>

<p>To get started, create a new gradle project. Then, add the following directories and files, which we will edit along the way.
(Alternatively you can clone the complete source code for this plugin <a href="https://github.com/AmiStrn/example-rest">here</a>)</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.
|-- LICENSE.txt
|-- NOTICE.txt
|-- build.gradle
`-- src
    |-- main
    |   `-- java
    |       `-- org
    |           `-- opensearch
    |               `-- rest
    |                   `-- action
    |                       |-- HelloWorldPlugin.java
    |                       |-- HelloWorldService.java
    |                       `-- RestHelloWorldAction.java
    |-- test
    |   `-- java
    |       `-- org
    |           `-- opensearch
    |               `-- rest
    |                   `-- action
    |                       `-- HelloWorldPluginTests.java
    `-- yamlRestTest
        |-- java
        |   `-- org
        |       `-- opensearch
        |           `-- rest
        |               `-- action
        |                   `-- HelloWorldClientYamlTestSuiteIT.java
        `-- resources
            `-- rest-api-spec
                |-- api
                |   `-- _plugins.hello_world.json
                `-- test
                    `-- _plugins.hello_world
                        |-- 10_basic.yml
                        `-- 20_hello_world.yml
</code></pre></div></div>

<hr />
<h2 id="the-buildgradle-of-our-plugin">The <code class="language-plaintext highlighter-rouge">build.gradle</code> of Our Plugin</h2>
<p>All OpenSearch plugins have the same general structure.
The plugin itself is a zip file that contains at the root:</p>
<ul>
  <li>The plugin <code class="language-plaintext highlighter-rouge">jar</code> files</li>
  <li><code class="language-plaintext highlighter-rouge">plugin-descriptor.properties</code></li>
  <li>[OPTIONAL] <code class="language-plaintext highlighter-rouge">bin</code> directory</li>
  <li>[OPTIONAL] <code class="language-plaintext highlighter-rouge">config</code> directory</li>
  <li>[OPTIONAL] <code class="language-plaintext highlighter-rouge">plugin-security.policy</code></li>
</ul>

<blockquote>
  <p>Any resources a plugin requires are packaged into a resources <code class="language-plaintext highlighter-rouge">jar</code>. This is due to the fact that only <code class="language-plaintext highlighter-rouge">jar</code> files at the root are added to the classpath for the plugin.</p>
</blockquote>

<p>The <code class="language-plaintext highlighter-rouge">build.gradle</code> file will build this structure for us when we are done, including creating the required <code class="language-plaintext highlighter-rouge">plugin-descriptor.properties</code>.</p>

<p>However, since we need the OpenSearch project artifact for the gradle build process and the plugin interface, letâ€™s clone the project and publish it to our Maven local. This last step is required since the artifact is not yet published to public repositories.</p>

<p>In this example I will be using release version <code class="language-plaintext highlighter-rouge">1.0.0-beta1</code>, as described <a href="https://github.com/opensearch-project/opensearch-plugins/blob/main/README.md">here</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  ~ git clone https://github.com/opensearch-project/OpenSearch.git
âžœ  ~ cd OpenSearch
âžœ  OpenSearch git:(main) git checkout 1.0.0-beta1 -b beta1-release
âžœ  OpenSearch git:(beta1-release) ./gradlew publishToMavenLocal -Dbuild.version_qualifier=beta1 -Dbuild.snapshot=false
</code></pre></div></div>

<p>Copy the following to the <code class="language-plaintext highlighter-rouge">build.gradle</code> file:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply plugin: 'java'
apply plugin: 'opensearch.opensearchplugin'
apply plugin: 'opensearch.yaml-rest-test'

opensearchplugin {
    name 'opensearch-rest-plugin'
    description 'Custom OpenSearch REST plugin for educational purposes'
    classname 'org.opensearch.rest.action.HelloWorldPlugin'
    licenseFile rootProject.file('LICENSE.txt')
    noticeFile rootProject.file('NOTICE.txt')
}

buildscript {
    repositories {
        mavenCentral()
        jcenter()
        mavenLocal()
    }

    dependencies {
        classpath "org.opensearch.gradle:build-tools:1.0.0-beta1"
    }
}

repositories {
    mavenLocal()
}

// disabling some unnecessary validations for this plugin
testingConventions.enabled = false
loggerUsageCheck.enabled = false
validateNebulaPom.enabled = false

dependencies {
    // required for the yaml test to run
    yamlRestTestImplementation 'org.apache.logging.log4j:log4j-core:2.11.1'
}
</code></pre></div></div>

<p>A few things to note on the <code class="language-plaintext highlighter-rouge">build.gradle</code>:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">opensearchplugin</code> section:
    <ul>
      <li>Every plugin must contain a file called <code class="language-plaintext highlighter-rouge">plugin-descriptor.properties</code> which contains some optional fields and some mandatory. In my example I included the mandatory ones only. You must provide: the full class path to the plugin file in your project (<code class="language-plaintext highlighter-rouge">classname</code>), the plugin name (<code class="language-plaintext highlighter-rouge">opensearch-rest-plugin</code>) and description, and the locations of your pluginâ€™s license and notice files.</li>
      <li>This section ensures that this file will be created in the pluginâ€™s build process using the properties provided in the curly braces.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">org.opensearch.gradle:build-tools:1.0.0-beta1</code>
    <ul>
      <li>The version at the end in this example is <code class="language-plaintext highlighter-rouge">1.0.0-beta1</code>, the version <strong>must match</strong> the version of the OpenSearch project we are going to install our plugin into. We are getting this artifact from our local maven repo.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">LICENSE.txt</code> and <code class="language-plaintext highlighter-rouge">NOTICE.txt</code> files:
    <ul>
      <li>These pertain to <strong>your</strong> plugin, and <strong>not</strong> to the core project.</li>
      <li>An example for the License and Notice files if youâ€™re interested in the Apache 2.0 license:</li>
    </ul>
  </li>
</ol>

<p>Example for <code class="language-plaintext highlighter-rouge">Notice.txt</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This product includes software developed by The Apache Software
Foundation (https://www.apache.org/).
</code></pre></div></div>
<p>And a copy of the Apache 2.0 license can be found <a href="https://www.apache.org/licenses/LICENSE-2.0">here</a>. 
Add your pluginâ€™s license and notice <code class="language-plaintext highlighter-rouge">.txt</code> files to your project and edit them later:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  opensearch-rest-plugin touch "./LICENSE.txt"
âžœ  opensearch-rest-plugin touch "./NOTICE.txt"
</code></pre></div></div>
<blockquote>
  <p><strong>I am <em>not</em> a lawyer</strong>. If youâ€™re not sure what to put in the <code class="language-plaintext highlighter-rouge">LICENSE.txt</code> and <code class="language-plaintext highlighter-rouge">NOTICE.txt</code> files, please consult one.</p>
</blockquote>

<hr />
<h2 id="implementing-the-plugin-code">Implementing the Plugin Code</h2>

<p>We are going to add the plugin under <code class="language-plaintext highlighter-rouge">/src/main/java/org/opensearch/rest/action</code>.</p>

<blockquote>
  <p>This is not an arbitrary directory! During the plugin installation your source code will be copied to this directory in the OpenSearch project, so you must select the relevant path depending on the type of plugin (more on this in a bit).</p>
</blockquote>

<p>Open the project in your favorite IDE, and edit <code class="language-plaintext highlighter-rouge">HelloWorldPlugin.java</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * SPDX-License-Identifier: Apache-2.0
 *
 * The OpenSearch Contributors require contributions made to
 * this file be licensed under the Apache-2.0 license or a
 * compatible open source license.
 */
package org.opensearch.rest.action;

import ...

public class HelloWorldPlugin extends Plugin implements ActionPlugin {

    @Override
    public List&lt;RestHandler&gt; getRestHandlers(final Settings settings,
                                             final RestController restController,
                                             final ClusterSettings clusterSettings,
                                             final IndexScopedSettings indexScopedSettings,
                                             final SettingsFilter settingsFilter,
                                             final IndexNameExpressionResolver indexNameExpressionResolver,
                                             final Supplier&lt;DiscoveryNodes&gt; nodesInCluster) {

        return singletonList(new RestHelloWorldAction());
    }
}
</code></pre></div></div>
<p>Notice we are extending <code class="language-plaintext highlighter-rouge">Plugin</code> and implementing the <code class="language-plaintext highlighter-rouge">ActionPlugin</code>. <strong>How did I reach the conclusion that I need to implement this particular interface?</strong></p>

<p>This is where we need to learn a little bit about the project we are plugging into.</p>

<hr />
<h2 id="opensearch-plugin-interfaces">OpenSearch Plugin Interfaces</h2>

<p>When creating a plugin we would want to implement at least one plugin interface class. For our simple example it seems we need a REST layer, so one interface should do. These are the current plugin interfaces available, found at the <a href="https://github.com/opensearch-project/OpenSearch/tree/main/server/src/main/java/org/opensearch/plugins">plugins</a> folder in the OpenSearch project:</p>

<!--- explain each one refine the explanations here! --->
<ul>
  <li><strong>ActionPlugin</strong> - Simply put, actions are things you can do over the API. This interface allows for extentind the REST API.</li>
  <li><strong>AnalysisPlugin</strong> - Extends analysis functionality (i.e. tokenizerâ€™s and char filters) on the index level.</li>
  <li><strong>ClusterPlugin</strong> - Extends the cluster management behavior, such as shard allocation.</li>
  <li><strong>DiscoveryPlugin</strong> - Extends OpenSearchâ€™s host discovery functionality.</li>
  <li><strong>EnginePlugin</strong> - For providing alternative engine implementations. This is used when a new index is created and affects how we read/write to that index.</li>
  <li><strong>ExtensiblePlugin</strong> - Provides a callback for extensible plugins to be informed of other plugins which extend them.</li>
  <li><strong>IndexStorePlugin</strong> - Provides alternative directory implementations (for the data being indexed).</li>
  <li><strong>IngestPlugin</strong> - A powerful tool! You can use it to add custom ingest processors that are applied to the docs when they are ingested into OpenSearch.</li>
  <li><strong>MapperPlugin</strong> - Extend this to add custom mappers.</li>
  <li><strong>NetworkPlugin</strong> - Plugin for extending network and transport related classes. This interface is used on the transport layer between nodes.</li>
  <li><strong>PersistentTaskPlugin</strong> - Plugin for registering persistent tasks executors.</li>
  <li><strong>ReloadablePlugin</strong> - Plugins usually implement this interface in order to allow a plugin to reload its state.</li>
  <li><strong>RepositoryPlugin</strong> - An interface for adding custom snapshot and restore repository implementations.</li>
  <li><strong>ScriptPlugin</strong> - Extends the scripting functionality.</li>
  <li><strong>SearchPlugin</strong> - Plugin for extending search time behavior (Aggregations, scoring, ).</li>
  <li><strong>SystemIndexPlugin</strong> - Plugin for defining system indices.</li>
</ul>

<p>So, I wanted to find which of these is the right one for adding a REST call. Simply reading the javadoc of the classes is not always as forthcoming as you would expect. Check out the description over the <code class="language-plaintext highlighter-rouge">ActionPlugin</code>:</p>
<blockquote>
  <p><em>An additional extension point for {@link Plugin}s that extends OpenSearchâ€™s scripting functionality.</em></p>
</blockquote>

<p>Instead, the best way to know which plugin interface to implement is to follow a similar flow in the project. 
Off the top of your head, what is the most simple REST call you send to OpenSearch?</p>

<p>For me it is the <code class="language-plaintext highlighter-rouge">/_cat</code> endpoint. So I set out to understand the flow of a simple endpoint that I am familiar with.
Searching the OpenSearch project for <code class="language-plaintext highlighter-rouge">"/_cat"</code> led me to a file called <code class="language-plaintext highlighter-rouge">RestCatAction</code>. Look at the files around this one, can you see that there is a naming convention/template?</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Rest</code> + specific function + <code class="language-plaintext highlighter-rouge">Action</code></li>
</ul>

<p>So a new endpoint <strong>like the one we wish to create</strong> would have to be in this path (now you know why i chose <code class="language-plaintext highlighter-rouge">org/opensearch/rest/action</code>), and have a name like <code class="language-plaintext highlighter-rouge">RestHelloWorldAction</code>. We will edit it later on.</p>

<p>Next, I wanted to know how OpenSearch registers all these routes? How would my pluginâ€™s new endpoint be properly exposed?
If you search for usages of the <code class="language-plaintext highlighter-rouge">RestCatAction</code> you will get to the <code class="language-plaintext highlighter-rouge">ActionModule</code>. This class has a method called <code class="language-plaintext highlighter-rouge">initRestHandlers()</code> which does exactly what I was looking for. If registering REST handlers is done here it stands to reason that REST handling for plugins is also done here. Simply searching for the word <code class="language-plaintext highlighter-rouge">"plugin"</code> led me to this block of code in the <code class="language-plaintext highlighter-rouge">initRestHandlers()</code> function:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        for (ActionPlugin plugin : actionPlugins) {
            for (RestHandler handler : plugin.getRestHandlers(settings, restController, clusterSettings, indexScopedSettings,
                    settingsFilter, indexNameExpressionResolver, nodesInCluster)) {
                registerHandler.accept(handler);
            }
        }
</code></pre></div></div>

<p>And there you have it! <code class="language-plaintext highlighter-rouge">ActionPlugin</code>â€™s have a function <code class="language-plaintext highlighter-rouge">getRestHandlers()</code> that returns the plugin REST handler of type <code class="language-plaintext highlighter-rouge">RestHandler</code>.</p>

<p>In conclusion:</p>
<ul>
  <li>We know we need to implement an <code class="language-plaintext highlighter-rouge">ActionPlugin</code> interface in order to be registered during the node startup.</li>
  <li>Our plugin needs to supply a <code class="language-plaintext highlighter-rouge">RestHandler</code> type of class. This means the new class we added (<code class="language-plaintext highlighter-rouge">RestHelloWorldAction</code>) should extend the <code class="language-plaintext highlighter-rouge">RestHandler</code> class.</li>
</ul>

<hr />
<h2 id="implementing-plugin-logic">Implementing Plugin logic</h2>
<p>Noticing that the majority of the REST action handlers are extending the <code class="language-plaintext highlighter-rouge">BaseRestHandler</code> which in turn extends the <code class="language-plaintext highlighter-rouge">RestHandler</code> led me to edit the <code class="language-plaintext highlighter-rouge">RestHelloWorldAction.java</code> file like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*...*/
package org.opensearch.rest.action;

import ...

public class RestHelloWorldAction extends BaseRestHandler {
    @Override
    public String getName() {
        return "rest_handler_hello_world";
    }

    @Override
    public List&lt;Route&gt; routes() {
        return unmodifiableList(asList(
                new Route(GET, "/_plugins/hello_world"),
                new Route(POST, "/_plugins/hello_world")));
    }

    @Override
    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {
        String name = request.hasContent()? request.contentParser().mapStrings().get("name"): "";

        return channel -&gt; {
            try {
                channel.sendResponse(HelloWorldService.buildResponse(name));
            } catch (final Exception e) {
                channel.sendResponse(new BytesRestResponse(channel, e));
            }
        };
    }
}
</code></pre></div></div>
<p>This implementation adds the routes we defined earlier. It also prepares the request for handling.</p>

<p>The incoming request first lands on the REST layer and is handled later (async) by an event loop. The request is processed into the tcp layer and then the response is sent back via the REST layer. This is, of course, an oversimplification of how actions are handled in OpenSearch.</p>
<blockquote>
  <p>if this asynchronous behavior and the way nodes communicate is a subject you would like to hear more about please let me know in the comments!</p>
</blockquote>

<hr />
<h2 id="logic-separation">Logic separation</h2>
<p>Please note that I am adding a new class called <code class="language-plaintext highlighter-rouge">HelloWorldService</code> to implement the <strong>logic</strong>. It would be wrong in this case to handle the logic at the time the endpoint is called rather than when the system is ready to handle the request. This separation also allows us to test the plugin logic and the integration of the new route <strong>separately</strong>.</p>

<p>Thatâ€™s what the <code class="language-plaintext highlighter-rouge">HelloWorldService</code> class is for - 
We could edit the class to be something like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*...*/
package org.opensearch.rest.action;

import ...

public class HelloWorldService {

    public static RestResponse buildResponse(String name) {
        String space = name.isEmpty()? "" : " ";
        final String message = "Hi" + space + name + "! Your plugin is installed and working:)";
        return new BytesRestResponse(RestStatus.OK, message);
    }
}
</code></pre></div></div>
<hr />
<h2 id="testing">Testing</h2>
<p>OpenSearch offers test cases for you to extend, that give you the ability to have common cluster configurations for many tests. Some of these offer a way to test your plugin as part of an OpenSearch instance. In order to test the integration with our new endpoint we can implement a YAML test. This type of test is recommended by the documentation for REST tests.</p>

<p>In order to run a YAML REST test we need to provide a resource containing the REST API spec adhering to the <a href="https://github.com/opensearch-project/OpenSearch/blob/main/rest-api-spec/README.md">api spec requirements</a>, and the YAML based tests describing the actions and the expected returned values.</p>

<p>As previously described, the YAML REST test file structure should be like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- src
    |
    `-- yamlRestTest
        |-- java
        |   `-- org
        |       `-- opensearch
        |           `-- rest
        |               `-- action
        |                   `-- HelloWorldClientYamlTestSuiteIT.java
        `-- resources
            `-- rest-api-spec
                |-- api
                |   `-- _plugins.hello_world.json
                `-- test
                    `-- _plugins.hello_world
                        |-- 10_basic.yml
                        `-- 20_hello_world.yml
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">10_basic.yml</code> will test that the plugin has been added, the other tests check if the rest endpoint is working as expected.
We can now edit the <code class="language-plaintext highlighter-rouge">_plugins.hello_world.json</code> to describe the new REST endpointâ€™s behaviour:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "_plugins.hello_world": {
    "stability" : "stable",
    "url": {
      "paths": [
        {
          "path": "/_plugins/hello_world",
          "methods": [
            "GET",
            "POST"
          ]
        }
      ]
    },
    "body": {
      "description": "The name to be included in the hello message"
    }
  }
}
</code></pre></div></div>

<p>And now the YAML tests themselves:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">10_basic.yml</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Test that the plugin is loaded in OpenSearch":
  - do:
      cat.plugins:
        local: true
        h: component

  - match:
      $body: /^opensearch-rest-plugin\n$/

</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">20_hello_world.yml</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
"Default with no name":
  - do:
      _plugins.hello_world: {}

  - match: {$body: "Hi! Your plugin is installed and working:)" }

---
"With name":
  - do:
      _plugins.hello_world:
        body:
          name: Amitai

  - match: {$body: "Hi Amitai! Your plugin is installed and working:)" }

</code></pre></div></div>

<p>The only thing we are missing is to edit the <code class="language-plaintext highlighter-rouge">HelloWorldClientYamlTestSuiteIT.java</code> file. When this file is run it runs the YAML cases we defined using a client against a running OpenSearch cluster.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">HelloWorldClientYamlTestSuiteIT.java</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*...*/
package org.opensearch.rest.action;

import ...


public class HelloWorldClientYamlTestSuiteIT extends OpenSearchClientYamlSuiteTestCase {

    public HelloWorldClientYamlTestSuiteIT(@Name("yaml") ClientYamlTestCandidate testCandidate) {
        super(testCandidate);
    }

    @ParametersFactory
    public static Iterable&lt;Object[]&gt; parameters() throws Exception {
        return OpenSearchClientYamlSuiteTestCase.createParameters();
    }
}

</code></pre></div></div>

<p>And that concludes the integration tests. We finish up by editing our unit test for the logic performed by the action:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*...*/
package org.opensearch.rest.action;

import ...

public class HelloWorldPluginTests extends OpenSearchTestCase {
    public void testBuildHelloWorldResponse() {
        String name = "What's in a name?";
        assertThat(HelloWorldService.buildResponse(name).content().utf8ToString(),
                equalTo("Hi " + name + "! Your plugin is installed and working:)"));
    }
}
</code></pre></div></div>

<p>Running the tests is as easy as:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  opensearch-rest-plugin gradle check
</code></pre></div></div>
<hr />
<h1 id="trying-out-our-new-plugin">Trying out our new plugin</h1>

<h2 id="building-the-plugin-project">Building the plugin project</h2>
<p>Now that everything is prepared building the plugin is as easy as:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  opensearch-rest-plugin gradle build 
</code></pre></div></div>

<p>We can find our built plugin zip in the <code class="language-plaintext highlighter-rouge">distributions</code> folder, letâ€™s take a look inside it:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  opensearch-rest-plugin vim build/distributions/opensearch-rest-plugin-0.0.1-SNAPSHOT.zip
</code></pre></div></div>
<p>You should see something like this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plugin-descriptor.properties
opensearch-rest-plugin-0.0.1-SNAPSHOT.jar
NOTICE.txt
LICENSE.txt
</code></pre></div></div>
<hr />
<h2 id="installing-the-plugin">Installing the plugin</h2>
<p>Installing the plugin into OpenSearch will require getting a distribution of the project, we can create one from the cloned OpenSearch repo:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  OpenSearch git:(beta1-release) ./gradlew localDistro
</code></pre></div></div>
<p>And installing our plugin to OpenSearch:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  OpenSearch git:(beta1-release) cd build/distribution/local/opensearch-1.0.0-SNAPSHOT
âžœ  opensearch-1.0.0-SNAPSHOT git:(beta1-release) bin/opensearch-plugin install  file:///full/path/to/opensearch-rest-plugin/build/distributions/opensearch-rest-plugin-0.0.1-SNAPSHOT.zip
</code></pre></div></div>
<hr />
<h2 id="running-opensearch-with-our-new-plugin">Running OpenSearch with our new plugin</h2>
<p>Now we can finally fire up OpenSearch and try out our new plugin!</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  opensearch-1.0.0-SNAPSHOT git:(beta1-release) bin/opensearch
</code></pre></div></div>
<p>After it starts running open a new terminal tab and run the following:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  ~ curl -XGET 'http://localhost:9200/_plugins/hello_world'
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Hi! Your plugin is installed and working:)
</code></pre></div></div>
<p>Or you can add your name by running this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  ~ curl -XPOST 'localhost:9200/_plugins/hello_world' -H 'Content-Type: application/json' -d '{"name":"Amitai"}'
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Hi Amitai! Your plugin is installed and working:)
</code></pre></div></div>

<p>AMAZING!!!</p>

<hr />
<h2 id="uninstalling-the-plugin">Uninstalling the plugin</h2>
<p>This is required if you want to make changes to the plugin and install it again. Installing a plugin with the same name twice results in an error.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âžœ  opensearch-1.0.0-SNAPSHOT git:(beta1-release) bin/OpenSearch-plugin remove opensearch-rest-plugin
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    -&gt; removing [opensearch-rest-plugin]...
</code></pre></div></div>

<hr />
<h1 id="key-takeaways-from-creating-my-first-plugin">Key takeaways from creating my first plugin</h1>
<p>I wonâ€™t lie to you, this simple plugin had a steep learning curve for understanding the full flow. I had everything and anything go wrong in the first try. It is important to remember that this is <strong>totally normal</strong> for large scale projects.</p>

<p>Having said that, here are some of the things I learned along the way:</p>
<ul>
  <li>There are complex plugins and there are simple plugins, but they are all created using this thought process:
    <ul>
      <li>What has a similar logic flow in the OpenSearch project to the logic I need my plugin to implement? -&gt; this gives you the plugin interface you are looking for.</li>
      <li>What methods does this plugin interface expose?</li>
      <li>What additional classes do you need to implement in order to satisfy these methods?</li>
    </ul>
  </li>
</ul>

<p>Adding a plugin that has to do with REST handling essentially has taught me all the basics of REST handling in OpenSearch. To top it off - creating this plugin boosted my confidence to go and explore other aspects of the OSS project.</p>

<hr />
<p>In this simple plugin use case we got to see the REST layer implementation, add an endpoint to the OpenSearch project and interact with it. In the following posts we will implement more complex plugins, getting to know other sections of this great project.</p>

<p>I would like to thank <a href="https://github.com/saratvemulapalli">Sarat Vemulapalli</a> from AWS for his feedback and assistance on this post.</p>

<hr />
<p>This post is contributed by Amitai Stern from Logz.io and is co-published on <a href="https://logz.io/blog/opensearch-plugins">Logz.io blog</a></p>
:ET